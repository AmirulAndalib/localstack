# LocalStack Resource Provider Scaffolding v2
from __future__ import annotations

from pathlib import Path
from typing import Optional, Type, TypedDict

import localstack.services.cloudformation.provider_utils as util
from localstack.services.cloudformation.resource_provider import (
    CloudFormationResourceProviderPlugin,
    OperationStatus,
    ProgressEvent,
    ResourceProvider,
    ResourceRequest,
)


class KinesisStreamProperties(TypedDict):
    Arn: Optional[str]
    Name: Optional[str]
    RetentionPeriodHours: Optional[int]
    ShardCount: Optional[int]
    StreamEncryption: Optional[StreamEncryption]
    StreamModeDetails: Optional[StreamModeDetails]
    Tags: Optional[list[Tag]]


class StreamModeDetails(TypedDict):
    StreamMode: Optional[str]


class StreamEncryption(TypedDict):
    EncryptionType: Optional[str]
    KeyId: Optional[str]


class Tag(TypedDict):
    Key: Optional[str]
    Value: Optional[str]


REPEATED_INVOCATION = "repeated_invocation"


class KinesisStreamProvider(ResourceProvider[KinesisStreamProperties]):

    TYPE = "AWS::Kinesis::Stream"  # Autogenerated. Don't change
    SCHEMA = util.get_schema_path(Path(__file__))  # Autogenerated. Don't change

    def create(
        self,
        request: ResourceRequest[KinesisStreamProperties],
    ) -> ProgressEvent[KinesisStreamProperties]:
        """
        Create a new resource.

        Primary identifier fields:
          - /properties/Name



        Create-only properties:
          - /properties/Name

        Read-only properties:
          - /properties/Arn

        IAM permissions required:
          - kinesis:EnableEnhancedMonitoring
          - kinesis:DescribeStreamSummary
          - kinesis:CreateStream
          - kinesis:IncreaseStreamRetentionPeriod
          - kinesis:StartStreamEncryption
          - kinesis:AddTagsToStream
          - kinesis:ListTagsForStream

        """
        model = request.desired_state
        client = request.aws_client_factory.kinesis

        # TODO: validations
        name = model.get("Name") or util.generate_default_name(
            request.stack_name, request.logical_resource_id
        )
        # todo: how to trigger error if len is not valid
        assert 1 <= len(name) <= 128

        if not request.custom_context.get(REPEATED_INVOCATION):
            # TODO: defaults
            # TODO: idempotency
            # TODO: actually create the resource

            request.custom_context[REPEATED_INVOCATION] = True

            client.create_stream(
                StreamName=name,
                ShardCount=model.get("ShardCount") or 1,
            )
            return ProgressEvent(
                status=OperationStatus.IN_PROGRESS,
                resource_model=model,
                custom_context=request.custom_context,
            )

        response = client.describe_stream(StreamName=name)
        status = response["StreamDescription"]["StreamStatus"]
        # should I update the ARN here?
        model["Arn"] = response["StreamDescription"]["StreamARN"]
        if status == "ACTIVE":
            return ProgressEvent(status=OperationStatus.SUCCESS, resource_model=model)
        return ProgressEvent(status=OperationStatus.IN_PROGRESS, resource_model=model)

    def read(
        self,
        request: ResourceRequest[KinesisStreamProperties],
    ) -> ProgressEvent[KinesisStreamProperties]:
        """
        Fetch resource information

        IAM permissions required:
          - kinesis:DescribeStreamSummary
          - kinesis:ListTagsForStream
        """
        raise NotImplementedError

    def delete(
        self,
        request: ResourceRequest[KinesisStreamProperties],
    ) -> ProgressEvent[KinesisStreamProperties]:
        """
        Delete a resource

        IAM permissions required:
          - kinesis:DescribeStreamSummary
          - kinesis:DeleteStream
          - kinesis:RemoveTagsFromStream
        """
        model = request.desired_state
        client = request.aws_client_factory.kinesis

        name = model.get("Name")
        assert name

        if not request.custom_context.get("deleting", False):
            client.delete_stream(StreamName=name)
            return ProgressEvent(
                status=OperationStatus.IN_PROGRESS,
                resource_model=model,
                custom_context={"deleting": True},
            )

        try:
            client.describe_stream(StreamName=name)
            return ProgressEvent(status=OperationStatus.SUCCESS, resource_model=model)
        except client.exceptions.ResourceNotFoundException:
            return ProgressEvent(status=OperationStatus.SUCCESS, resource_model=model)

    def update(
        self,
        request: ResourceRequest[KinesisStreamProperties],
    ) -> ProgressEvent[KinesisStreamProperties]:
        """
        Update a resource

        IAM permissions required:
          - kinesis:EnableEnhancedMonitoring
          - kinesis:DisableEnhancedMonitoring
          - kinesis:DescribeStreamSummary
          - kinesis:UpdateShardCount
          - kinesis:UpdateStreamMode
          - kinesis:IncreaseStreamRetentionPeriod
          - kinesis:DecreaseStreamRetentionPeriod
          - kinesis:StartStreamEncryption
          - kinesis:StopStreamEncryption
          - kinesis:AddTagsToStream
          - kinesis:RemoveTagsFromStream
          - kinesis:ListTagsForStream
        """
        raise NotImplementedError


class KinesisStreamProviderPlugin(CloudFormationResourceProviderPlugin):
    name = "AWS::Kinesis::Stream"

    def __init__(self):
        self.factory: Optional[Type[ResourceProvider]] = None

    def load(self):
        self.factory = KinesisStreamProvider
